"""
Experiment to evaluate the number of trials needed for three factorization methods:
- Pell's method
- Pollard's method  
- Williams' method

This script compares how many trials each method needs to successfully factor N = p*q
with an ideal choice of smoothness bound B = e^{sqrt(ln(N) * ln(ln(N)))}
"""


# This file was *autogenerated* from the file experiment.sage
from sage.all_cmdline import *   # import sage library

_sage_const_20 = Integer(20); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_10 = Integer(10); _sage_const_50 = Integer(50); _sage_const_0 = Integer(0); _sage_const_70 = Integer(70); _sage_const_100 = Integer(100)
# Import the factorization methods from each file
load("pellconic.sage")
load("pollard.sage")
load("williams.sage")

import random
from collections import defaultdict
from math import log, sqrt, exp

def generate_semiprime(bit_length=_sage_const_20 ):
    """
    Generate a semiprime N = p * q where p and q are distinct primes.
    
    Args:
        bit_length: approximate bit length for each prime factor
    
    Returns:
        N: the semiprime product
        p, q: the prime factors
    """
    p = random_prime(_sage_const_2 **bit_length, lbound=_sage_const_2 **(bit_length-_sage_const_1 ))
    q = random_prime(_sage_const_2 **bit_length, lbound=_sage_const_2 **(bit_length-_sage_const_1 ))
    while p == q:
        q = random_prime(_sage_const_2 **bit_length, lbound=_sage_const_2 **(bit_length-_sage_const_1 ))
    N = p * q
    return N, p, q

def compute_ideal_B(N):
    """
    Compute the ideal smoothness bound B = e^{sqrt(ln(N) * ln(ln(N)))}
    
    Args:
        N: the number to be factored
    
    Returns:
        B: the smoothness bound (as an integer)
    """
    ln_N = log(float(N))
    ln_ln_N = log(ln_N)
    B = exp(sqrt(ln_N * ln_ln_N))
    return int(B)

def run_experiment(num_tests=_sage_const_10 , bit_length=_sage_const_20 , max_trials=_sage_const_50 ):
    """
    Run the factorization experiment comparing all three methods.
    
    Args:
        num_tests: number of different semiprimes to test
        bit_length: bit length for generating prime factors
        max_trials: maximum number of trials before giving up
    
    Returns:
        results: dictionary with statistics for each method
    """
    # Dictionary to store trial counts for each method
    trial_counts = {
        'pell': [],
        'pollard': [],
        'williams': []
    }
    
    # Dictionary to store success/failure counts
    success_counts = {
        'pell': _sage_const_0 ,
        'pollard': _sage_const_0 ,
        'williams': _sage_const_0 
    }

    # Dictionary to store the factor found
    result_log = {
        'pell': [],
        'pollard': [],
        'williams': []
    }
    
    print("=" * _sage_const_70 )
    print("FACTORIZATION METHOD COMPARISON EXPERIMENT")
    print("=" * _sage_const_70 )
    print(f"Number of tests: {num_tests}")
    print(f"Prime bit length: {bit_length}")
    print(f"Max trials per method: {max_trials}")
    print("=" * _sage_const_70 )
    print()
    
    for test_num in range(_sage_const_1 , num_tests + _sage_const_1 ):
        # Generate semiprime N = p * q
        N, p, q = generate_semiprime(bit_length)
        B = compute_ideal_B(N)
        
        print(f"Test {test_num}/{num_tests}:")
        print(f"  N = {N} = {p} Ã— {q}")
        print(f"  Ideal B = {B}")
        print()
        
        # Test Pell's method
        print("  Testing Pell's method...")
        for trial in range(_sage_const_1 , max_trials + _sage_const_1 ):
            result = pell_method(N, B)
            if result != "failure":
                trial_counts['pell'].append(trial)
                result_log['pell'].append(result)
                success_counts['pell'] += _sage_const_1 
                print(f"   Success on trial {trial}, found factor: {result}")
                break
        else:
            result_log['pell'].append(-_sage_const_1 )
            print(f"    Failed after {max_trials} trials")
        
        # Test Pollard's method
        print("  Testing Pollard's method...")
        for trial in range(_sage_const_1 , max_trials + _sage_const_1 ):
            result = pollard_method(N, B)
            if result != "failure":
                trial_counts['pollard'].append(trial)
                result_log['pollard'].append(result)
                success_counts['pollard'] += _sage_const_1 
                print(f"    Success on trial {trial}, found factor: {result}")
                break
        else:
            result_log['pollard'].append(-_sage_const_1 )
            print(f"    Failed after {max_trials} trials")
        
        # Test Williams' method
        print("  Testing Williams' method...")
        for trial in range(_sage_const_1 , max_trials + _sage_const_1 ):
            result = williams_method(N, B)
            if result != "failure":
                trial_counts['williams'].append(trial)
                result_log['williams'].append(result)
                success_counts['williams'] += _sage_const_1 
                print(f"    Success on trial {trial}, found factor: {result}")
                break
        else:
            print(f"    Failed after {max_trials} trials")
            result_log['williams'].append(-_sage_const_1 )
        
        print()
    
    # Print summary statistics
    print("=" * _sage_const_70 )
    
    for method in ['pell', 'pollard', 'williams']:
        print(f"\n{method.upper()}'S METHOD:")
        print(f"  Successes: {success_counts[method]}/{num_tests}")
        
        if trial_counts[method]:
            trials = trial_counts[method]
            print("Number of trials", trials)
            print("Results", result_log[method])
        else:
            print("  No successful factorizations")
    
    print("\n" + "=" * _sage_const_70 )
    
    return {
        'trial_counts': trial_counts,
        'success_counts': success_counts
    }

# Run the experiment
if __name__ == "__main__":
    # You can adjust these parameters:
    # - num_tests: how many different N values to test
    # - bit_length: size of prime factors (20 bits = ~6 digit primes)
    # - max_trials: maximum attempts before giving up
    
    results = run_experiment(num_tests=_sage_const_100 , bit_length=_sage_const_20 , max_trials=_sage_const_50 )




