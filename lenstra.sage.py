

# This file was *autogenerated* from the file lenstra.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_27 = Integer(27); _sage_const_583421287793 = Integer(583421287793); _sage_const_12762 = Integer(12762)
from sage.all import EllipticCurve, IntegerModRing, gcd, primes, randint, log, floor
import re

def lenstra_method(N, B):
    R = IntegerModRing(N)

    x0 = randint(_sage_const_1 , N - _sage_const_1 )
    y0 = randint(_sage_const_1 , N - _sage_const_1 )
    a  = randint(_sage_const_1 , N - _sage_const_1 )

    b = R(y0)**_sage_const_2  - R(x0)**_sage_const_3  - R(a)*R(x0)

    disc = _sage_const_4 *(a**_sage_const_3 ) + _sage_const_27 *(b**_sage_const_2 )
    g = gcd(disc, N)
    if _sage_const_1  < g < N:
        return g
    if g == N:
        return "failure"

    E = EllipticCurve(R, [a, b])
    P = E(x0, y0)

    # print(f"(x,y) = ({P[0]}, {P[1]})")

    for l in primes(_sage_const_2 , B + _sage_const_1 ):
        e = ceil(log(N, l))
        E = l**e

        try:
            P = E * P
            # print(f"(x,y) = ({P[0]}, {P[1]})")

        except ZeroDivisionError as err:
            # Inversion failed â†’ extract factor
            # Sage raises ZeroDivisionError when inverse mod N doesn't exist
            # The offending denominator is usually in err.args
            m = re.search(r'Inverse of (\d+) does not exist', str(err))
            if m:
                v = int(m.group(_sage_const_1 ))
                g = gcd(v, N)
                if _sage_const_1  < g < N:
                    return g
            return "failure"

    return "failure"


if __name__ == "__main__":
    N = _sage_const_583421287793 
    B = _sage_const_12762 
    factor = lenstra_method(N, B)
    print("Factor found:", factor)

