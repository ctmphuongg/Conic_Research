

# This file was *autogenerated* from the file pellconic.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_583421287793 = Integer(583421287793); _sage_const_12762 = Integer(12762)
from sage.all import gcd, inverse_mod, Integers, var, prime_range
from random import randint

from sage.all import Integers, cached_function

def add_point(P1, P2, d, R):
    """
    Add two points P1 = (r,s) and P2 = (t,u) on the Pell conic x^2 - d*y^2 = 1 over R = Z/NZ.
    Returns (x3, y3) modulo R.
    """
    r, s = P1
    t, u = P2
    x3 = r*t + s*u*d
    y3 = r*u + s*t
    return R(x3), R(y3)


# @cached_function
def self_add_two_power(two_power, P, delta, R):
    """
    Compute 2^k * P on the Pell conic using repeated doubling.
    """
    if two_power == _sage_const_0 :
        return P  # 2^0 * P = P
    
    prev = self_add_two_power(two_power - _sage_const_1 , P, delta, R)
    return add_point(prev, prev, delta, R)


def self_add_optimized(n, P, delta, R):
    if n == _sage_const_0 :
        return R(_sage_const_1 ), R(_sage_const_0 )

    result = (R(_sage_const_1 ), R(_sage_const_0 ))  # identity
    first = True
    for bit in bin(n)[_sage_const_2 :]:  # MSB -> LSB
        if not first:
            result = add_point(result, result, delta, R)  # double
        if bit == '1':
            if first:
                result = P
                first = False
            else:
                result = add_point(result, P, delta, R)  # add P
        else:
            first = False  # after first bit processed
    return result

def pell_method(N, B):
    """
    Factor N using a Pell-conic method with bound B.
    Returns a nontrivial factor or 'failure' if none found.
    """

    R = Integers(N)  # modular ring
    a = randint(_sage_const_1 , N-_sage_const_1 )
    b = randint(_sage_const_1 , N-_sage_const_1 )

    # Quick gcd checks, make sure b invertible
    g = gcd(a, N)
    if _sage_const_1  < g < N:
        return g
    g = gcd(b, N)
    if _sage_const_1  < g < N:
        return g

    xN, yN = R(a), R(b)
    b_inv = inverse_mod(b**_sage_const_2 , N) # b must be invertible due to prev check
    d = ((a**_sage_const_2 -_sage_const_1 ) * b_inv)

    # print(f"(x,y) = ({xN},{yN})")
    for l in primes(_sage_const_2 , B+_sage_const_1 ):
        # Find e such that p^(e-1) < N <= p^e
        e = ceil(log(N, l))
        E = l**e

        # Multiply point by p^e
        xN, yN = self_add_optimized(E, (xN, yN), d, R)
        # print(f"(x,y) = ({xN},{yN})")

        g = gcd([xN-_sage_const_1 , yN, N])
        if g != _sage_const_1  and g != N:
            return g

    return "failure"

if __name__ == "__main__":
    N = _sage_const_583421287793 
    B = _sage_const_12762 
    factor = pell_method(N, B)
    print("Factor found:", factor)
    # factor2 = pell_method(357, 6)
    # print("Factor found:", factor2)

